"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.kleLayoutToVIALayout = exports.extractGroups = exports.getBoundingBox = exports.findPivot = exports.filterGroups = exports.rawKLEToKLELayout = void 0;
var invariant_1 = __importDefault(require("invariant"));
var inspect = JSON.stringify;
var types_common_1 = require("./types.common");
var ENCODER_REGEX = /^[eE]\d+\s*$/;
var LED_REGEX = /^[lL]\d+\s*$/;
function rawKLEToKLELayout(kle) {
    var kleArr = kle.split(',\n');
    return kleArr.map(function (row) {
        return JSON.parse(row
            .replace(/\n/g, '\\n')
            .replace(/\\/g, '\\\\')
            .replace(/\"\\(?!,)/g, '\\\\')
            .replace(/([{,])([A-Za-z][0-9A-Za-z]?)(:)/g, '$1"$2"$3'));
    });
}
exports.rawKLEToKLELayout = rawKLEToKLELayout;
function filterGroups(keys) {
    // Currently extract out non x,0 groups i.e. always choose the first option
    return keys.filter(function (key) { return key.group.option === 0; });
}
exports.filterGroups = filterGroups;
// Finds the closest to the top-left corner
function findPivot(keys) {
    return __spreadArray([], keys, true).sort(function (a, b) {
        var yDiff = a.y - b.y;
        return yDiff !== 0 ? yDiff : a.x - b.x;
    })[0];
}
exports.findPivot = findPivot;
function getPivotPoint(a) {
    // complicated keys like ISO and BAE combine two rectangles
    // so first identify the top-left most rectangle and then get that
    // point
    var x = a.x, y = a.y, _a = a.x2, x2 = _a === void 0 ? 0 : _a, _b = a.y2, y2 = _b === void 0 ? 0 : _b;
    var isSecondRect = y2 === 0 ? x > x + x2 : y2 < 0;
    return isSecondRect
        ? { x: x + x2, y: y + y2 }
        : {
            x: x,
            y: y,
        };
}
// New and improved algorithm: identify top and the leftmost corner of each pivot and
// measure the distance between those two
function calculateDelta2(a, b) {
    var aPivotPoint = getPivotPoint(a);
    var bPivotPoint = getPivotPoint(b);
    return {
        x: bPivotPoint.x - aPivotPoint.x,
        y: bPivotPoint.y - aPivotPoint.y,
    };
}
function getBoundingBox(key) {
    var _a = key.x2, x2 = _a === void 0 ? 0 : _a, _b = key.y2, y2 = _b === void 0 ? 0 : _b, x = key.x, y = key.y, _c = key.w, w = _c === void 0 ? 1 : _c, _d = key.h, h = _d === void 0 ? 1 : _d, _e = key.r, r = _e === void 0 ? 0 : _e, _f = key.rx, rx = _f === void 0 ? 0 : _f, _g = key.ry, ry = _g === void 0 ? 0 : _g;
    var _h = key.h2, h2 = _h === void 0 ? h : _h, _j = key.w2, w2 = _j === void 0 ? w : _j;
    var extraArgs = [rx, ry, r];
    var box = {
        xStart: Math.min(x, x + x2),
        yStart: Math.min(y, y + y2),
        xEnd: Math.max(x + w, x + x2 + w2),
        yEnd: Math.max(y + h, y + y2 + h2),
    };
    var rotatedPoints = [
        { x: box.xStart, y: box.yStart },
        { x: box.xEnd, y: box.yStart },
        { x: box.xStart, y: box.yEnd },
        { x: box.xEnd, y: box.yEnd },
    ].map(function (p) { return applyRotation.apply(void 0, __spreadArray([p.x, p.y], extraArgs, false)); });
    return {
        xStart: Math.min.apply(Math, rotatedPoints.map(function (p) { return p.x; })),
        xEnd: Math.max.apply(Math, rotatedPoints.map(function (p) { return p.x; })),
        yStart: Math.min.apply(Math, rotatedPoints.map(function (p) { return p.y; })),
        yEnd: Math.max.apply(Math, rotatedPoints.map(function (p) { return p.y; })),
    };
}
exports.getBoundingBox = getBoundingBox;
function applyRotation(x, y, xOrigin, yOrigin, rotation) {
    var rad = (rotation * Math.PI) / 180;
    var _a = [x - xOrigin, y - yOrigin], normX = _a[0], normY = _a[1];
    return {
        x: xOrigin + normX * Math.cos(rad) - normY * Math.sin(rad),
        y: yOrigin + normX * Math.sin(rad) + normY * Math.cos(rad),
    };
}
function extractGroups(keys, origin, colorMap) {
    var groups = keys.filter(function (key) { return key.group.key !== -1; });
    var groupedKeys = groups.reduce(function (p, n) {
        var _a, _b;
        return (__assign(__assign({}, p), (_a = {}, _a[n.group.key] = __assign(__assign({}, (p[n.group.key] || {})), (_b = {}, _b[n.group.option] = ((p[n.group.key] || {})[n.group.option] || []).concat(n), _b)), _a)));
    }, {});
    // We need two pivots in order to calculate the true placement
    // 1. The option 0 pivot + the option n pivot for the rest of them
    return Object.entries(groupedKeys).reduce(function (p, _a) {
        var _b;
        var group = _a[0], options = _a[1];
        var zeroPivot = findPivot(options[0]);
        var normalizedOptions = Object.entries(options).reduce(function (p, _a) {
            var _b;
            var option = _a[0], results = _a[1];
            return (__assign(__assign({}, p), (_b = {}, _b[option] = (function (delta) {
                return results.map(function (res) { return (__assign(__assign({}, res), { x: res.x - delta.x, y: res.y - delta.y })); });
            })(calculateDelta2(zeroPivot, findPivot(results))).map(function (r) {
                return resultToVIAKey(r, origin, colorMap);
            }), _b)));
        }, {});
        return __assign(__assign({}, p), (_b = {}, _b[group] = normalizedOptions, _b));
    }, {});
}
exports.extractGroups = extractGroups;
// Expects pairs to be in the format "x,y" else throws exception
function extractPair(pair) {
    if (!pair) {
        throw new Error("'Row,col' pairs must be placed in the top-left legend in the KLE keymap provided in the definition.");
    }
    var arr = pair.split(/[ï¼Œ,]/);
    (0, invariant_1.default)(arr.length === 2, "".concat(pair, " is not a pair"));
    var numArr = arr.map(function (v) { return parseInt(v, 10); });
    if (numArr.some(function (num) { return Number.isNaN(num); })) {
        throw new Error("Invalid pair: ".concat(pair));
    }
    return numArr;
}
function resultToVIAKey(result, delta, colorMap) {
    var c = result.c, t = result.t, group = result.group, partialKey = __rest(result, ["c", "t", "group"]);
    return __assign(__assign({}, partialKey), { x: result.x - delta.x, y: result.y - delta.y, rx: result.rx - delta.x, ry: result.ry - delta.y, color: colorMap["".concat(c, ":").concat(t)] || types_common_1.KeyColorType.Alpha });
}
/** Copied from ijprest/kle-serial
 */
var alignmentArr = [
    [0, 6, 2, 8, 9, 11, 3, 5, 1, 4, 7, 10],
    [1, 7, -1, -1, 9, 11, 4, -1, -1, -1, -1, 10],
    [3, -1, 5, -1, 9, 11, -1, -1, 4, -1, -1, 10],
    [4, -1, -1, -1, 9, 11, -1, -1, -1, -1, -1, 10],
    [0, 6, 2, 8, 10, -1, 3, 5, 1, 4, 7, -1],
    [1, 7, -1, -1, 10, -1, 4, -1, -1, -1, -1, -1],
    [3, -1, 5, -1, 10, -1, -1, -1, 4, -1, -1, -1],
    [4, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1], // 7 = center front & x & y
];
var normalizeLabels = function (labels, a) {
    if (a === void 0) { a = 0; }
    var normalizedLabels = [];
    var labelArr = labels.split('\n');
    labelArr.forEach(function (label, idx) {
        normalizedLabels[alignmentArr[a][idx]] = label.trim();
    });
    return normalizedLabels;
};
var KeyDataIndex;
(function (KeyDataIndex) {
    KeyDataIndex[KeyDataIndex["LED"] = 6] = "LED";
    KeyDataIndex[KeyDataIndex["ROWCOL"] = 0] = "ROWCOL";
    KeyDataIndex[KeyDataIndex["GROUP"] = 8] = "GROUP";
    KeyDataIndex[KeyDataIndex["ENCODER"] = 4] = "ENCODER";
})(KeyDataIndex || (KeyDataIndex = {}));
var getKeyData = function (normalizedLabels, isDecal) {
    var keyData = {};
    var fakeRowCol = [-1, -1];
    var fakeGroupOption = [-1, 0];
    var encoderLabel = normalizedLabels[KeyDataIndex.ENCODER];
    if (encoderLabel && ENCODER_REGEX.test(encoderLabel)) {
        keyData['ei'] = +encoderLabel.slice(1);
    }
    var ledLabel = normalizedLabels[KeyDataIndex.LED];
    if (ledLabel && LED_REGEX.test(ledLabel)) {
        keyData['li'] = +ledLabel.slice(1);
    }
    var rowColLabel = normalizedLabels[KeyDataIndex.ROWCOL];
    var _a = isDecal || (keyData['ei'] !== undefined && !rowColLabel)
        ? fakeRowCol
        : extractPair(rowColLabel), row = _a[0], col = _a[1];
    var groupLabel = normalizedLabels[KeyDataIndex.GROUP];
    var _b = groupLabel
        ? extractPair(groupLabel)
        : fakeGroupOption, group = _b[0], option = _b[1];
    return __assign(__assign({}, keyData), { group: { key: group, option: option }, row: row, col: col });
};
function kleLayoutToVIALayout(kle) {
    var _a;
    var filteredKLE = kle.filter(function (elem) { return Array.isArray(elem); });
    var parsedKLE = filteredKLE.reduce(function (prev, kle) {
        var parsedRow = kle.reduce(function (_a, n) {
            var _b;
            var _c = _a.cursor, x = _c.x, y = _c.y, res = _a.res, c = _a.c, h = _a.h, t = _a.t, r = _a.r, d = _a.d, rx = _a.rx, ry = _a.ry, w = _a.w, a = _a.a, y2 = _a.y2, x2 = _a.x2, w2 = _a.w2, h2 = _a.h2, colorCount = _a.colorCount;
            // Check if object and apply formatting
            if (typeof n !== 'string') {
                var obj = {
                    colorCount: colorCount,
                    a: a,
                    c: c,
                    t: t,
                    h: h,
                    r: r,
                    rx: rx,
                    ry: ry,
                    res: res,
                    d: d,
                    w: w,
                    cursor: { x: x, y: y },
                };
                obj = ['y2', 'x2', 'w2', 'h2', 'r', 'rx', 'ry', 'h', 'w'].reduce(function (p, prop) {
                    var _a;
                    return typeof n[prop] === 'number' ? __assign(__assign({}, p), (_a = {}, _a[prop] = n[prop], _a)) : p;
                }, obj);
                if (typeof n.d === 'boolean') {
                    obj = __assign(__assign({}, obj), { d: n.d });
                }
                if (typeof n.ry === 'number' || typeof n.rx === 'number') {
                    obj = __assign(__assign({}, obj), { cursor: __assign(__assign({}, obj.cursor), { y: obj.ry }) });
                }
                if (typeof n.y === 'number') {
                    obj = __assign(__assign({}, obj), { cursor: __assign(__assign({}, obj.cursor), { y: obj.cursor.y + n.y }) });
                }
                if (typeof n.x === 'number') {
                    obj = __assign(__assign({}, obj), { cursor: __assign(__assign({}, obj.cursor), { x: x + n.x }) });
                }
                if (typeof n.a === 'number') {
                    obj = __assign(__assign({}, obj), { a: n.a });
                }
                if (typeof n.c === 'string') {
                    obj = __assign(__assign({}, obj), { c: n.c });
                }
                if (typeof n.t === 'string') {
                    obj = __assign(__assign({}, obj), { t: n.t });
                }
                return obj;
            }
            else if (typeof n === 'string') {
                // Keys can currently be
                // 1. Matrix
                // 2. Matrix + Group
                // 3. Decal
                // 4. Encoder
                // 5. Encoder + Group
                // 6. Encoder + Matrix (Encoder with Click)
                // 7. Encoder + Matrix + Group (Encoder with Click)
                var colorCountKey = "".concat(c, ":").concat(t);
                var currKey = {};
                var keyData = getKeyData(normalizeLabels(n, a), d);
                var newColorCount = __assign(__assign({}, colorCount), (_b = {}, _b[colorCountKey] = colorCount[colorCountKey] === undefined
                    ? 1
                    : colorCount[colorCountKey] + 1, _b));
                currKey = __assign(__assign(__assign({}, currKey), keyData), {
                    c: c,
                    t: t,
                    x: x + rx,
                    y: y,
                    r: r,
                    rx: rx,
                    ry: ry,
                    d: d,
                    h: h,
                    w: w,
                    w2: w2,
                    y2: y2,
                    x2: x2,
                    h2: h2,
                });
                // Reset carry properties
                return {
                    h: 1,
                    w: 1,
                    r: r,
                    rx: rx,
                    a: a,
                    ry: ry,
                    c: c,
                    d: false,
                    colorCount: newColorCount,
                    t: t,
                    cursor: { x: x + w, y: y },
                    res: __spreadArray(__spreadArray([], res, true), [currKey], false),
                };
            }
            return {
                a: a,
                c: c,
                t: t,
                h: h,
                d: d,
                r: r,
                w: w,
                rx: rx,
                ry: ry,
                res: res,
                colorCount: colorCount,
                cursor: { x: x, y: y },
            };
        }, __assign(__assign({}, prev.prevRow), { cursor: prev.cursor, colorCount: prev.colorCount, h: 1, w: 1, d: false, res: [] }));
        return {
            cursor: { x: 0, y: parsedRow.cursor.y + 1 },
            colorCount: parsedRow.colorCount,
            prevRow: {
                c: parsedRow.c,
                t: parsedRow.t,
                r: parsedRow.r,
                rx: parsedRow.rx,
                ry: parsedRow.ry,
                a: parsedRow.a,
            },
            res: __spreadArray(__spreadArray([], prev.res, true), [parsedRow.res], false),
        };
    }, {
        cursor: { x: 0, y: 0 },
        prevRow: { c: '#cccccc', t: '#000000', r: 0, rx: 0, ry: 0, a: 0 },
        res: [],
        colorCount: {},
    });
    var colorCount = parsedKLE.colorCount, res = parsedKLE.res;
    var colorCountKeys = Object.keys(colorCount);
    colorCountKeys.sort(function (a, b) { return colorCount[b] - colorCount[a]; });
    if (colorCountKeys.length > 3) {
        throw new Error('Please correct layout, too many colors:' + '\n' + inspect(colorCount));
    }
    var colorMap = (_a = {},
        _a[colorCountKeys[0]] = types_common_1.KeyColorType.Alpha,
        _a[colorCountKeys[1]] = types_common_1.KeyColorType.Mod,
        _a[colorCountKeys[2]] = types_common_1.KeyColorType.Accent,
        _a);
    var flatRes = res.flat();
    var defaultRes = filterGroups(flatRes);
    var boundingBoxes = defaultRes.map(getBoundingBox);
    var minX = Math.min.apply(Math, boundingBoxes.map(function (b) { return b.xStart; }));
    var minY = Math.min.apply(Math, boundingBoxes.map(function (b) { return b.yStart; }));
    var width = Math.max.apply(Math, boundingBoxes.map(function (b) { return b.xEnd; })) - minX;
    var height = Math.max.apply(Math, boundingBoxes.map(function (b) { return b.yEnd; })) - minY;
    var keys = defaultRes
        .filter(function (k) { return k.group.key === -1; }) // Remove option keys
        .map(function (k) { return resultToVIAKey(k, { x: minX, y: minY }, colorMap); });
    var optionKeys = extractGroups(flatRes, { x: minX, y: minY }, colorMap);
    return { width: width, height: height, optionKeys: optionKeys, keys: keys };
}
exports.kleLayoutToVIALayout = kleLayoutToVIALayout;
