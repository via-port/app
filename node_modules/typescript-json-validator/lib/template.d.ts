import Ajv from 'ajv';
import * as TJS from 'typescript-json-schema';
export declare const TSLINT_DISABLE = "/* tslint:disable */";
export declare const GENERATED_COMMENT = "// generated by typescript-json-validator";
export declare const IMPORT_INSPECT = "import {inspect} from 'util';";
export declare const IMPORT_AJV: (tsConfig: any) => string;
export declare const DECLARE_KOA_CONTEXT = "export interface KoaContext {\n  readonly request?: unknown; // {body?: unknown}\n  readonly params?: unknown;\n  readonly query?: unknown;\n  throw(status: 400, message: string): unknown;\n}";
export declare const importNamedTypes: (names: string[], relativePath: string) => string;
export declare const importDefaultType: (name: string, relativePath: string) => string;
export declare const importType: (name: string, relativePath: string, { isNamedExport }: {
    isNamedExport: boolean;
}) => string;
export declare const declareAJV: (options: Ajv.Options) => string;
export declare const exportNamed: (names: string[]) => string;
export declare const declareSchema: (name: string, schema: TJS.Definition) => string;
export declare const addSchema: (name: string) => string;
export declare const DECLARE_VALIDATE_TYPE = "export type ValidateFunction<T> = ((data: unknown) => data is T) & Pick<Ajv.ValidateFunction, 'errors'>";
export declare const validateType: (typeName: string) => string;
export declare const compileSchema: (schemaName: string, typeName: string) => string;
export declare const validateFn: (typeName: string, schemaName: string) => string;
export declare const validateKoaRequestOverload: (typeName: string, schema: TJS.Definition) => string;
export declare const VALIDATE_KOA_REQUEST_FALLBACK = "export function validateKoaRequest(typeName: string): (ctx: KoaContext) => {\n  params: unknown,\n  query: unknown,\n  body: unknown,\n};";
export declare const VALIDATE_KOA_REQUEST_IMPLEMENTATION = "export function validateKoaRequest(typeName: string): (ctx: KoaContext) => {\n  params: any,\n  query: any,\n  body: any,\n} {\n  const params = ajv.getSchema(`Schema#/definitions/${typeName}/properties/params`);\n  const query = ajv.getSchema(`Schema#/definitions/${typeName}/properties/query`);\n  const body = ajv.getSchema(`Schema#/definitions/${typeName}/properties/body`);\n  const validateProperty = (\n    prop: string,\n    validator: any,\n    ctx: KoaContext,\n  ): any => {\n    const data = prop === 'body' ? ctx.request && (ctx.request as any).body : (ctx as any)[prop];\n    if (validator) {\n      const valid = validator(data);\n  \n      if (!valid) {\n        ctx.throw(\n          400,\n          'Invalid request: ' + ajv.errorsText(validator.errors!.filter((e: any) => e.keyword !== 'if'), {dataVar: prop}) + '\\n\\n' + inspect({params: ctx.params, query: ctx.query, body: ctx.request && (ctx.request as any).body}),\n        );\n      }\n    }\n    return data;\n  };\n  return (ctx) => {\n    return {\n      params: validateProperty('params', params, ctx),\n      query: validateProperty('query', query, ctx),\n      body: validateProperty('body', body, ctx),\n    }\n  };\n}";
export declare const validateOverload: (typeName: string) => string;
export declare const VALIDATE_IMPLEMENTATION = "export function validate(typeName: string): (value: unknown) => any {\n  const validator: any = ajv.getSchema(`Schema#/definitions/${typeName}`);\n  return (value: unknown): any => {\n    if (!validator) {\n      throw new Error(`No validator defined for Schema#/definitions/${typeName}`)\n    }\n  \n    const valid = validator(value);\n\n    if (!valid) {\n      throw new Error(\n        'Invalid ' + typeName + ': ' + ajv.errorsText(validator.errors!.filter((e: any) => e.keyword !== 'if'), {dataVar: typeName}),\n      );\n    }\n\n    return value as any;\n  };\n}";
